#!/usr/bin/env python2

"""
SYNOPSIS

    Aggregate the variant_calls data in the input MAF at the per-Gene, per-Codon
    level. Create an output table that counts up the 'Num_Samples_with_Mutation'
    at each GENE+Codon position.

    Additionally use the information from target BED files to figure out the
    'Num_Samples_Targeted' and 'Num_Samples_not_Targeted' at each GENE+Codon
    position.

    Finally, also extract annotations from the input MAF and report them in the
    output table as well, including:

        (1) ExaC frequency of each GENE+Codon position (computed as max of the
            ExAC frequencies of corresponding nucleotide positions).

        (2) Ensembl's Gene_ID for each GENE+Codon position.

        (3) Ensembl's Transcript_ID for each GENE+Codon position.

        (4) Alternate Amino-acids generated by the Missense mutations at each
            GENE+Codon position.

NOTES

    (1) This script uses the sample information in MAF file to count up the # of
        samples targeted by each BED file as well as the total number of samples.

        This potentially undercounts the # of samples since a sample will appear
        in the MAF file ONLY if it has at least 1 variant call. To account for
        samples with no variant calls, it may be better to instead count up the
        # of samples from the clinical data file.

    (2) The script currently filter input MAF data for only Missense SNP.

EXAMPLES

    # (1) On combined DFCI + METABRIC datasets. Input clinical data. Output
    #     only clinical p-values and odd-ratios.
    ./count_mutations.py \
        --in_maf private/dfci_plus_metabric.r6.vep.maf \
        --in_clinical private/merged.clinical_data.r13.tsv \
        --in_source_maf_ids dfci.DFCI-ONCOPANEL-1.r4.vep.maf \
                            dfci.DFCI-ONCOPANEL-2.r4.vep.maf \
                            dfci.DFCI-ONCOPANEL-3.r4.vep.maf \
                            metabric.vep.maf \
        --in_target_beds ../examples/inputs/private/dfci.PROFILE_POPv1.filtered.r1.bed \
                         ../examples/inputs/private/dfci.PROFILE_POPv2.filtered.r1.bed \
                         ../examples/inputs/private/dfci.PROFILE_POPv3.r1.bed \
                         ../examples/inputs/public/metabric.targetedIntervals.r1.bed \
        --output_clinical_counts \
        --out_table private/count_table.txt

    # (2) Same as (1) but detect hotspot using a logistic regression model
    #     instead of just the count-based model. Lower min_count to 3, but now
    #     report only hotspots with statistically significant qvalues.
    ./count_mutations.py \
        --in_maf private/dfci_plus_metabric.r6.vep.maf \
        --in_clinical private/merged.clinical_data.r13.tsv \
        --in_source_maf_ids dfci.DFCI-ONCOPANEL-1.r4.vep.maf \
                            dfci.DFCI-ONCOPANEL-2.r4.vep.maf \
                            dfci.DFCI-ONCOPANEL-3.r4.vep.maf \
                            metabric.vep.maf \
        --in_target_beds ../examples/inputs/private/dfci.PROFILE_POPv1.filtered.r1.bed \
                         ../examples/inputs/private/dfci.PROFILE_POPv2.filtered.r1.bed \
                         ../examples/inputs/private/dfci.PROFILE_POPv3.r1.bed \
                         ../examples/inputs/public/metabric.targetedIntervals.r1.bed \
        --min_count 3 \
        --run_hotspot_stats_model \
        --gene_annotation_gtf ../pipeline_resources/gene_annotation/r1/CDS_only.Homo_sapiens.GRCh37.85.r1.gtf \
        --ref_fasta ../pipeline_resources/ref_genome/GRCh37_r2/Homo_sapiens.GRCh37.75.dna.primary_assembly.fa \
        --ref_fasta_fai ../pipeline_resources/ref_genome/GRCh37_r2/Homo_sapiens.GRCh37.75.dna.primary_assembly.fa.fai \
        --output_clinical_counts \
        --out_table private/count_table.txt

    # (3) On combined DFCI + All public datasets. Input clinical data. Output
    #     only clinical p-values and odd-ratios.
    ./count_mutations.py \
        --in_maf private/merged.dfci_plus_public.r6.vep.maf \
        --in_clinical private/merged.clinical_data.r13.tsv \
        --in_source_maf_ids dfci.DFCI-ONCOPANEL-1.r4.vep.maf \
                            dfci.DFCI-ONCOPANEL-2.r4.vep.maf \
                            dfci.DFCI-ONCOPANEL-3.r4.vep.maf \
                            genie_msk.IMPACT341.r3.vep.maf \
                            genie_msk.IMPACT410.r3.vep.maf \
                            metabric.vep.maf \
                            sanger_somatic_coding_annotated.maf \
                            tcga.cell_2015.r2.vep.maf \
        --in_target_beds ../examples/inputs/private/dfci.PROFILE_POPv1.filtered.r1.bed \
                         ../examples/inputs/private/dfci.PROFILE_POPv2.filtered.r1.bed \
                         ../examples/inputs/private/dfci.PROFILE_POPv3.r1.bed \
                         ../examples/inputs/public/genie/genie_msk.IMPACT341.r1.bed \
                         ../examples/inputs/public/genie/genie_msk.IMPACT410.r1.bed \
                         ../examples/inputs/public/metabric.targetedIntervals.r1.bed \
                         ../examples/inputs/public/from_intelccc/sanger_target_r1.bed \
                         ../examples/inputs/public/tcga_brca/tcga_target_v2.bed \
        --out_table private/count_table.txt

    # (4) Same as (3) but Additionally:
    #       - Also specify '--output_clinical_counts' option to output extra columns
    #         which provides the sample counts by each clinical indicator.
    #       - Also specify '--percenter_breakdown' option to output extra columns
    #         which provides breakdown of sample counts by Center.
    #     Note: These two options should NOT be used with private datasets inside
    #           IntelCCC Reliance-Point.
    ./count_mutations.py \
        --in_maf private/merged.dfci_plus_public.r6.vep.maf \
        --in_clinical private/merged.clinical_data.r13.tsv \
        --in_source_maf_ids dfci.DFCI-ONCOPANEL-1.r4.vep.maf \
                            dfci.DFCI-ONCOPANEL-2.r4.vep.maf \
                            dfci.DFCI-ONCOPANEL-3.r4.vep.maf \
                            genie_msk.IMPACT341.r3.vep.maf \
                            genie_msk.IMPACT410.r3.vep.maf \
                            metabric.vep.maf \
                            sanger_somatic_coding_annotated.maf \
                            tcga.cell_2015.r2.vep.maf \
        --in_target_beds ../examples/inputs/private/dfci.PROFILE_POPv1.filtered.r1.bed \
                         ../examples/inputs/private/dfci.PROFILE_POPv2.filtered.r1.bed \
                         ../examples/inputs/private/dfci.PROFILE_POPv3.r1.bed \
                         ../examples/inputs/public/genie/genie_msk.IMPACT341.r1.bed \
                         ../examples/inputs/public/genie/genie_msk.IMPACT410.r1.bed \
                         ../examples/inputs/public/metabric.targetedIntervals.r1.bed \
                         ../examples/inputs/public/from_intelccc/sanger_target_r1.bed \
                         ../examples/inputs/public/tcga_brca/tcga_target_v2.bed \
        --output_clinical_counts \
        --percenter_breakdown \
        --out_table private/count_table.txt

    # (5) Same as (4) but detect hotspot using a logistic regression model
    #     instead of just the count-based model.
    ./count_mutations.py \
        --in_maf ../private/merged.dfci_plus_public.r6.vep.maf \
        --in_clinical ../private/merged.clinical_data.r13.tsv \
        --in_source_maf_ids dfci.DFCI-ONCOPANEL-1.r4.vep.maf \
                            dfci.DFCI-ONCOPANEL-2.r4.vep.maf \
                            dfci.DFCI-ONCOPANEL-3.r4.vep.maf \
                            genie_msk.IMPACT341.r3.vep.maf \
                            genie_msk.IMPACT410.r3.vep.maf \
                            metabric.vep.maf \
                            sanger_somatic_coding_annotated.maf \
                            tcga.cell_2015.r2.vep.maf \
        --in_target_beds ../examples/inputs/private/dfci.PROFILE_POPv1.filtered.r1.bed \
                         ../examples/inputs/private/dfci.PROFILE_POPv2.filtered.r1.bed \
                         ../examples/inputs/private/dfci.PROFILE_POPv3.r1.bed \
                         ../examples/inputs/public/genie/genie_msk.IMPACT341.r1.bed \
                         ../examples/inputs/public/genie/genie_msk.IMPACT410.r1.bed \
                         ../examples/inputs/public/metabric.targetedIntervals.r1.bed \
                         ../examples/inputs/public/from_intelccc/sanger_target_r1.bed \
                         ../examples/inputs/public/tcga_brca/tcga_target_v2.bed \
        --min_count 3 \
        --run_hotspot_stats_model \
        --gene_annotation_gtf ../pipeline_resources/gene_annotation/r1/CDS_only.Homo_sapiens.GRCh37.85.r1.gtf \
        --ref_fasta ../pipeline_resources/ref_genome/GRCh37_r2/Homo_sapiens.GRCh37.75.dna.primary_assembly.fa \
        --ref_fasta_fai ../pipeline_resources/ref_genome/GRCh37_r2/Homo_sapiens.GRCh37.75.dna.primary_assembly.fa.fai \
        --output_clinical_counts \
        --percenter_breakdown \
        --out_table ../private/count_table.txt

    # (6) Same as (4) but only on Public (MSK-IMPACT, METABRIC, Sanger, TCGA).
    #     Excludes DFCI data.
    ./count_mutations.py \
        --in_maf private/merged.only_public.r6.vep.maf \
        --in_clinical private/merged.clinical_data.only_public.r13.tsv \
        --in_source_maf_ids genie_msk.IMPACT341.r3.vep.maf \
                            genie_msk.IMPACT410.r3.vep.maf \
                            metabric.vep.maf \
                            sanger_somatic_coding_annotated.maf \
                            tcga.cell_2015.r2.vep.maf \
        --in_target_beds ../examples/inputs/public/genie/genie_msk.IMPACT341.r1.bed \
                         ../examples/inputs/public/genie/genie_msk.IMPACT410.r1.bed \
                         ../examples/inputs/public/metabric.targetedIntervals.r1.bed \
                         ../examples/inputs/public/from_intelccc/sanger_target_r1.bed \
                         ../examples/inputs/public/tcga_brca/tcga_target_v2.bed \
        --run_hotspot_stats_model \
        --gene_annotation_gtf ../pipeline_resources/gene_annotation/r1/CDS_only.Homo_sapiens.GRCh37.85.r1.gtf \
        --ref_fasta ../pipeline_resources/ref_genome/GRCh37_r2/Homo_sapiens.GRCh37.75.dna.primary_assembly.fa \
        --ref_fasta_fai ../pipeline_resources/ref_genome/GRCh37_r2/Homo_sapiens.GRCh37.75.dna.primary_assembly.fa.fai \
        --output_clinical_counts \
        --percenter_breakdown \
        --out_table private/count_table.txt

    # (7) Same as (6) but very permissive hotspot filtering. Output all hotspots with
    #     1 or more count (min_count:1) and don't filter hotspots by Q-value.
    ./count_mutations.py \
        --in_maf private/merged.only_public.r6.vep.maf \
        --in_clinical private/merged.clinical_data.only_public.r13.tsv \
        --in_source_maf_ids genie_msk.IMPACT341.r3.vep.maf \
                            genie_msk.IMPACT410.r3.vep.maf \
                            metabric.vep.maf \
                            sanger_somatic_coding_annotated.maf \
                            tcga.cell_2015.r2.vep.maf \
        --in_target_beds ../examples/inputs/public/genie/genie_msk.IMPACT341.r1.bed \
                         ../examples/inputs/public/genie/genie_msk.IMPACT410.r1.bed \
                         ../examples/inputs/public/metabric.targetedIntervals.r1.bed \
                         ../examples/inputs/public/from_intelccc/sanger_target_r1.bed \
                         ../examples/inputs/public/tcga_brca/tcga_target_v2.bed \
        --run_hotspot_stats_model \
        --gene_annotation_gtf ../pipeline_resources/gene_annotation/r1/CDS_only.Homo_sapiens.GRCh37.85.r1.gtf \
        --ref_fasta ../pipeline_resources/ref_genome/GRCh37_r2/Homo_sapiens.GRCh37.75.dna.primary_assembly.fa \
        --ref_fasta_fai ../pipeline_resources/ref_genome/GRCh37_r2/Homo_sapiens.GRCh37.75.dna.primary_assembly.fa.fai \
        --output_clinical_counts \
        --hotspot_qvalue_cutoff 1.00001 \
        --min_count 1 \
        --percenter_breakdown \
        --out_table private/count_table.txt

EDGE_CASES

    # Edge Case #1: No clinical data for all centers
    ./count_mutations.py \
        --in_maf private/dfci_plus_metabric.r6.vep.maf \
        --in_source_maf_ids dfci.DFCI-ONCOPANEL-1.r4.vep.maf \
                            dfci.DFCI-ONCOPANEL-2.r4.vep.maf \
                            dfci.DFCI-ONCOPANEL-3.r4.vep.maf \
                            metabric.vep.maf \
        --in_target_beds ../examples/inputs/private/dfci.PROFILE_POPv1.filtered.r1.bed \
                         ../examples/inputs/private/dfci.PROFILE_POPv2.filtered.r1.bed \
                         ../examples/inputs/private/dfci.PROFILE_POPv3.r1.bed \
                         ../examples/inputs/public/metabric.targetedIntervals.r1.bed \
        --out_table private/tmp.count_table.txt

    # Edge Case #2: No clinical data for single center (DFCI).
    ./count_mutations.py \
        --in_maf private/dfci_plus_metabric.r6.vep.maf \
        --in_clinical private/merged.clinical_data.missing_dfci.r13.tsv \
        --in_source_maf_ids dfci.DFCI-ONCOPANEL-1.r4.vep.maf \
                            dfci.DFCI-ONCOPANEL-2.r4.vep.maf \
                            dfci.DFCI-ONCOPANEL-3.r4.vep.maf \
                            metabric.vep.maf \
        --in_target_beds ../examples/inputs/private/dfci.PROFILE_POPv1.filtered.r1.bed \
                         ../examples/inputs/private/dfci.PROFILE_POPv2.filtered.r1.bed \
                         ../examples/inputs/private/dfci.PROFILE_POPv3.r1.bed \
                         ../examples/inputs/public/metabric.targetedIntervals.r1.bed \
        --output_clinical_counts \
        --percenter_breakdown \
        --out_table private/tmp.count_table.txt

    # Edge Case #3: Only include the ER+ subset for METABRIC samples. Run Hotspot
                    detection stat model.
    ./count_mutations.py \
        --in_maf private/dfci_plus_metabric.r6.vep.maf \
        --in_clinical private/merged.clinical_data.er_pos_subset_metabric.r13.tsv \
        --in_source_maf_ids dfci.DFCI-ONCOPANEL-1.r4.vep.maf \
                            dfci.DFCI-ONCOPANEL-2.r4.vep.maf \
                            dfci.DFCI-ONCOPANEL-3.r4.vep.maf \
                            metabric.vep.maf \
        --in_target_beds ../examples/inputs/private/dfci.PROFILE_POPv1.filtered.r1.bed \
                         ../examples/inputs/private/dfci.PROFILE_POPv2.filtered.r1.bed \
                         ../examples/inputs/private/dfci.PROFILE_POPv3.r1.bed \
                         ../examples/inputs/public/metabric.targetedIntervals.r1.bed \
        --min_count 3 \
        --run_hotspot_stats_model \
        --gene_annotation_gtf ../pipeline_resources/gene_annotation/r1/CDS_only.Homo_sapiens.GRCh37.85.r1.gtf \
        --ref_fasta ../pipeline_resources/ref_genome/GRCh37_r2/Homo_sapiens.GRCh37.75.dna.primary_assembly.fa \
        --ref_fasta_fai ../pipeline_resources/ref_genome/GRCh37_r2/Homo_sapiens.GRCh37.75.dna.primary_assembly.fa.fai \
        --output_clinical_counts \
        --percenter_breakdown \
        --out_table private/tmp.count_table.txt

    # Edge Case #4: Don't perform Biopsy_Site_Type filtering
    ./count_mutations.py \
        --in_maf private/dfci_plus_metabric.r6.vep.maf \
        --in_clinical private/merged.clinical_data.r13.tsv \
        --in_source_maf_ids dfci.DFCI-ONCOPANEL-1.r4.vep.maf \
                            dfci.DFCI-ONCOPANEL-2.r4.vep.maf \
                            dfci.DFCI-ONCOPANEL-3.r4.vep.maf \
                            metabric.vep.maf \
        --in_target_beds ../examples/inputs/private/dfci.PROFILE_POPv1.filtered.r1.bed \
                         ../examples/inputs/private/dfci.PROFILE_POPv2.filtered.r1.bed \
                         ../examples/inputs/private/dfci.PROFILE_POPv3.r1.bed \
                         ../examples/inputs/public/metabric.targetedIntervals.r1.bed \
        --biopsy_site_type_filter NONE \
        --out_table private/tmp.count_table.txt

    # Edge Case #5: Specify an 'in_source_maf_id' that doesn't exist in the input
    #               merged MAF file.
    #    Expected Behavior: Raise Appropriate Exception.
    ./count_mutations.py \
        --in_maf private/dfci_plus_metabric.r6.vep.maf \
        --in_clinical private/merged.clinical_data.r13.tsv \
        --in_source_maf_ids dfci.DFCI-ONCOPANEL-1.r4.vep.maf \
                            dfci.DFCI-ONCOPANEL-2.r4.vep.maf \
                            dfci.DFCI-ONCOPANEL-3.r4.vep.maf \
                            metabric.vep.maf \
                            foo_missing.maf \
                            bar_missing.maf \
        --in_target_beds ../examples/inputs/private/dfci.PROFILE_POPv1.filtered.r1.bed \
                         ../examples/inputs/private/dfci.PROFILE_POPv2.filtered.r1.bed \
                         ../examples/inputs/private/dfci.PROFILE_POPv3.r1.bed \
                         ../examples/inputs/public/metabric.targetedIntervals.r1.bed \
                         ../examples/inputs/public/wgs.target.r1.bed \
                         ../examples/inputs/public/wgs.target.r1.bed \
        --out_table private/count_table.txt

    # Edge Case #6: Same as EXAMPLE command-line (2) above but Don't generate the
    #               output table. This (omit output) feature is necessary as an
    #               IntelCCC's Reliance Point workaround to get the stdout log.
    #    Expected Behavior: Don't generate the output table but produce the same
    #                       stdout as the regular run.
    ./count_mutations.py \
        --in_maf private/merged.dfci_plus_public.r6.vep.maf \
        --in_clinical private/merged.clinical_data.r13.tsv \
        --in_source_maf_ids dfci.DFCI-ONCOPANEL-1.r4.vep.maf \
                            dfci.DFCI-ONCOPANEL-2.r4.vep.maf \
                            dfci.DFCI-ONCOPANEL-3.r4.vep.maf \
                            genie_msk.IMPACT341.r3.vep.maf \
                            genie_msk.IMPACT410.r3.vep.maf \
                            metabric.vep.maf \
                            sanger_somatic_coding_annotated.maf \
                            tcga.cell_2015.r2.vep.maf \
        --in_target_beds ../examples/inputs/private/dfci.PROFILE_POPv1.filtered.r1.bed \
                         ../examples/inputs/private/dfci.PROFILE_POPv2.filtered.r1.bed \
                         ../examples/inputs/private/dfci.PROFILE_POPv3.r1.bed \
                         ../examples/inputs/public/genie/genie_msk.IMPACT341.r1.bed \
                         ../examples/inputs/public/genie/genie_msk.IMPACT410.r1.bed \
                         ../examples/inputs/public/metabric.targetedIntervals.r1.bed \
                         ../examples/inputs/public/from_intelccc/sanger_target_r1.bed \
                         ../examples/inputs/public/tcga_brca/tcga_target_v2.bed

AUTHOR
    Parin Sripakdeevong <parin@jimmy.harvard.edu> (April-2017)
"""

import sys
import platform

# Confirm that this script is being ran with a CPython v2.7.X interpreter.
is_correct_interpreter = True
if platform.python_implementation() != "CPython":
    is_correct_interpreter = False

if sys.version_info[0:2] != (2, 7):
    is_correct_interpreter = False

if not is_correct_interpreter:
    sys.stderr.write("Error: Unsupported Python Interpreter:")
    sys.stderr.write(" (%s, %s).\n" % (platform.python_implementation(), sys.version_info[0:3]))
    sys.stderr.write("\n")
    sys.stderr.write("Please call 'count_mutations.py' using a CPython v2.7.X Interpreter.\n")
    sys.exit(1)

import os
import time
import copy
import argparse
import math
import random

import pandas as pd
import numpy as np
import scipy as sp
import scipy.stats as stats
import statsmodels.api
import pybedtools

from collections import namedtuple

import create_ref_trinuc_map
import hotspot_stats_model
import clinical_enrichment_tests

HIDE_SENSITIVE_LOGS = True

VERSION = 'mc_v0.9_dev'

CLINICAL_COLUMNS = ['Tumor_Sample_Barcode', 'Center', 'ER_Status', 'PR_Status',
                    'HER2_Status', 'Biopsy_Site_Type', 'Histology_Type', 'Gender']

RECEPTORS = ['ER', 'PR', 'HER2']
RECEPTOR_STATUSES = ['Positive', 'Negative', 'Unknown']

BIOPSY_SITE_TYPES = ['Primary', 'Local_Recurrence', 'Metastatic', 'Unknown']

HISTOLOGY_TYPES = ['Invasive_Ductal_Carcinoma', 'Invasive_Lobular_Carcinoma',
                   'Mixed_Ductal_and_Lobular_Carcinoma', 'Other_Invasive_Breast_Carcinoma',
                   'Other_Breast_Cancer', 'Unknown']

GENDER_TYPES = ['Female', 'Male', 'Unknown']

CLINICAL_INDICATORS = ['ER+', 'ER-', 'HER2+', 'HER2-', 'TN', 'Not_TN', 'ER+/HER2+', 'ER-/HER2+',
                       'ER+/PR+', 'ER+/PR-', 'IDC', 'ILC', 'IDC/ER+', 'ILC/ER+']

CLINICAL_TESTS = ['ER+_vs_ER-', 'HER2+_vs_HER2-', 'TN_vs_Not_TN', 'ER+/HER2+_vs_ER-/HER2+',
                  'ER+/PR+_vs_ER+/PR-', 'IDC_vs_ILC', 'IDC/ER+_vs_ILC/ER+']

CodonID = namedtuple("CodonID", ["gene_id", "transcript_id", "codon_pos"])


def main(options):

    maf_df = import_annotated_maf(options.in_maf)

    if options.in_clinical:
        have_clinical_data = True

        clinical_df = import_clinical_df(options.in_clinical)

        clinical_df = add_default_clinical_data(maf_df, clinical_df)

        clinical_df = add_clinical_indicator_columns(clinical_df)

        if not HIDE_SENSITIVE_LOGS:
            print_cli_count_breakdown(clinical_df, 'Gender')
            print_cli_count_breakdown(clinical_df, 'Biopsy_Site_Type')

        compare_maf_and_clinical(maf_df, clinical_df, " [Before Any Filtering(s)]")

        print "##\n## Performing 'EXCLUDE_MISSING_CLINICAL' Filtering..."
        maf_df, clinical_df = perform_missing_clinical_filtering(maf_df, clinical_df)

        if not HIDE_SENSITIVE_LOGS:
            compare_maf_and_clinical(maf_df, clinical_df, " [Mid-Filtering #1]")

        print "##\n## Performing 'EXCLUDE_MALE' Gender Filtering..."
        maf_df, clinical_df = perform_gender_filtering(maf_df, clinical_df, 'EXCLUDE_MALE')

        if options.biopsy_site_type_filter != 'NONE':
            if not HIDE_SENSITIVE_LOGS:
                compare_maf_and_clinical(maf_df, clinical_df, " [Mid-Filtering #2]")
            print "##\n## Performing '%s' Biopsy_Site_Type Filtering..." % options.biopsy_site_type_filter
            maf_df, clinical_df = perform_biopsy_site_type_filtering(maf_df, clinical_df, options.biopsy_site_type_filter)

        compare_maf_and_clinical(maf_df, clinical_df, ' [After All Filtering]')

    else:
        have_clinical_data = False
        clinical_df = None

    # Note
    # ----
    # Important to tally-up samples before filtering MAF for Missense SNP variant
    # calls since samples with no Missense SNP variant calls will disappear after
    # the filtering.
    #
    # Import information about how many samples are targeted/not-targeted
    # at each BED interval.
    source_maf_id2target_intervals = map_source_maf_id_to_target_intervals(options.in_source_maf_ids,
                                                                           options.in_target_beds)

    source_maf_id2num_samples = map_source_maf_id_to_num_samples(options.in_source_maf_ids,
                                                                 maf_df, clinical_df)


    if options.in_clinical:
        if not HIDE_SENSITIVE_LOGS:
            print "##"
            print "## Clinical Indicator Count Summary:"
            print_clinical_indicator_summary(source_maf_id2num_samples)

    source_maf_id2center = map_source_maf_id_to_center(options.in_source_maf_ids, maf_df)

    centers = list(maf_df['Center'].unique())
    check_center(centers)

    maf_df = apply_missense_snp_filter(maf_df)

    maf_df = apply_exac_filter(maf_df)

    check_annotated_maf(maf_df)

    # Aggregate data at the per-Gene, per-Transcript, per-Codon level
    codon_level_dict = aggregate_codon_level_data(maf_df, clinical_df)

    if options.min_count > 0:
        codon_level_dict = apply_min_count_filter(codon_level_dict,
                                                  options.min_count)

    if options.run_hotspot_stats_model:
        # Use logistic regression model to detect statistically significant hotspots
        stats_data_list = run_hotspot_stats_model(maf_df,
                                                  source_maf_id2target_intervals,
                                                  source_maf_id2num_samples,
                                                  source_maf_id2center,
                                                  options.min_count,
                                                  options.gene_annotation_gtf,
                                                  options.ref_fasta,
                                                  options.ref_fasta_fai,
                                                  options.use_toy_stats_model)

        transcript_id2gene_symbol = map_transcript_id2gene_symbol(maf_df)

        add_stats_data_to_codon_level_dict(stats_data_list, codon_level_dict, transcript_id2gene_symbol)

        if options.hotspot_qvalue_cutoff <= 1.0:
            codon_level_dict = apply_is_hotspot_qvalue_filter(codon_level_dict, options.hotspot_qvalue_cutoff)
        else:
            print "##"
            print "## WARNING: Skip 'hotspot_qvalue_filter()' since hotspot_qvalue_cutoff > 1.0."

    # Print WARNING messages for debugging purposes.
    check_gene2transcript_mapping(codon_level_dict)

    # --------------------------------------------------------- #
    # Create Output table and Perform clinical enrichment tests #
    # --------------------------------------------------------- #
    params = {
        'codon_level_dict': codon_level_dict,
        'source_maf_id2target_intervals': source_maf_id2target_intervals,
        'source_maf_id2num_samples': source_maf_id2num_samples,
        'source_maf_id2center': source_maf_id2center,
        'have_clinical_data': have_clinical_data,
        'run_hotspot_stats_model': options.run_hotspot_stats_model,
        'output_clinical_counts': options.output_clinical_counts,
        'percenter_breakdown': options.percenter_breakdown
    }
    o = clinical_enrichment_tests.OutputDataTable(params)
    o.create_count_table()

    if options.out_table is not None:
        write_output_table(o.out_data_table, options.out_table)


def add_default_clinical_data(maf_df, cli_df):
    """For any center with genomics data BUT no clinical data, add default clinical
    data for the all (maf) samples from that center.

    Notes
    -----
    This is a temporary feature is deal with the current issue of missing clinical
    data for OSHU center. Generally, the default value of each clinical indicator
    should be 'Unknown'. However for 'Biopsy_Site_Type' column, set default value
    to 'Primary' so that the sample will not be filtered-out when this script is
    ran with the '--biopsy_site_type_filter PRIMARY_ONLY' option.
    """

    maf_centers = set(maf_df['Center'].unique())
    cli_centers = set(cli_df['Center'].unique())
    maf_only_centers = maf_centers - cli_centers

    # Consistency check that there is no duplicated samples between the two groups
    samples_in_maf_only_centers = set(maf_df[maf_df['Center'].isin(maf_only_centers)]['Tumor_Sample_Barcode'].unique())
    samples_in_cli = set(cli_df['Tumor_Sample_Barcode'].unique())
    assert len(samples_in_maf_only_centers & samples_in_cli) == 0

    if len(maf_only_centers) > 0:
        toadd_cli_data_list = list()

        for center in maf_only_centers:
            print "##"
            print "## WARNING: Center '%s' has genomics data but NO clinical data." % center,
            print "Will add default clinical data."

            samples = set(maf_df[maf_df['Center'] == center]['Tumor_Sample_Barcode'].unique())
            for sample in samples:
                cli_data = dict()
                cli_data['Tumor_Sample_Barcode'] = sample
                cli_data['Center'] = center
                cli_data['ER_Status'] = 'Unknown'
                cli_data['PR_Status'] = 'Unknown'
                cli_data['HER2_Status'] = 'Unknown'
                cli_data['Biopsy_Site_Type'] = 'Primary'
                cli_data['Histology_Type'] = 'Unknown'
                cli_data['Gender'] = 'Unknown'
                toadd_cli_data_list.append(cli_data)

        toadd_cli_df = pd.DataFrame(toadd_cli_data_list)

        # Check that identical columns are found in the two dataframes and then
        # reorder the columns to match
        assert set(cli_df) == set(toadd_cli_df)
        toadd_cli_df = toadd_cli_df[list(cli_df)]

        # Concatenate the two dataframe
        cli_df = pd.concat([cli_df, toadd_cli_df], axis=0)

        # Reset 'Tumor_Sample_Barcode' as the index of the Dataframe (for fast
        # lookup in downstream functions).
        cli_df.index = cli_df['Tumor_Sample_Barcode']

        check_clinical_df(cli_df)

    return cli_df

def compare_maf_and_clinical(maf_df, cli_df, desc_text=''):
    """Print information about the overlap and non-overlap of the samples and
    centers found in maf_df and clinical_df for logging/debugging purposes."""

    print "##"
    print "## MAF and Clinical Samples Count Summary%s:" % desc_text

    centers = set(maf_df['Center'].unique()) | set(cli_df['Center'].unique())
    centers = sorted(centers)

    print "##"
    print "##  ",
    print "   ".join(["%-20s" % var for var in ["Center", "Num_Overlap_Samples",
                                                "Num_MAF_only_Samples",
                                                "Num_Clinical_only_Samples"]])
    print "##   " + "-" * 94

    for center in centers:

        maf_samples = set(maf_df[maf_df['Center'] == center]['Tumor_Sample_Barcode'].unique())
        cli_samples = set(cli_df[cli_df['Center'] == center]['Tumor_Sample_Barcode'].unique())

        num_overlap_samples = len(maf_samples & cli_samples)
        num_maf_only_samples = len(maf_samples - cli_samples)
        num_cli_only_samples = len(cli_samples - maf_samples)


        print "##  ",
        print "   ".join(["%-20s" % var for var in [center, format(num_overlap_samples, ',d'),
                                                    format(num_maf_only_samples , ',d'),
                                                    format(num_cli_only_samples, ',d')]])

def print_clinical_indicator_summary(source_maf_id2num_samples):
    """Print a summary of each clinical indictor counts broken down by source_maf_id."""

    source_maf_ids = sorted(source_maf_id2num_samples.keys())

    header_cols = ['Source_MAF_ID', 'Total'] + CLINICAL_INDICATORS

    data_cols = list()
    for source_maf_id in source_maf_ids:
        row  = list([source_maf_id])
        for indicator in ['Total'] + CLINICAL_INDICATORS:
            count = source_maf_id2num_samples[source_maf_id][indicator]
            row.append(format(count, ',d'))
        data_cols.append(row)

    num_cols = len(header_cols)
    num_data_rows = len(data_cols)
    col_widths = list()
    for col_index in range(num_cols):
        cols = [header_cols[col_index]] + [data_cols[row_index][col_index] for row_index in range(num_data_rows)]
        col_widths.append(max([len(var) for var in cols]))

    print "##"
    print "##  ",
    print "   ".join(["%-*s" % (col_widths[col_index], header_cols[col_index]) for col_index in xrange(num_cols)])
    print "##   " + "-" * (sum(col_widths) + len("   ") * len(col_widths) - 3)
    for row_index in range(num_data_rows):
        print "##  ",
        print "   ".join(["%-*s" % (col_widths[col_index], data_cols[row_index][col_index]) for col_index in xrange(num_cols)])

def print_histology_type_summary(cli_df):
    """Print a count summary of the Histology_Type values found at the various centers for
    logging/debugging purposes."""

    centers = sorted(set(cli_df['Center'].unique()))

    header_cols = ['Center              '] + HISTOLOGY_TYPES
    num_cols = len(header_cols)
    col_widths = [len(colname) for colname in header_cols]

    print "##"
    print "##  ",
    print "   ".join(["%-*s" % (col_widths[i], header_cols[i]) for i in xrange(num_cols)])
    print "##   " + "-" * (sum(col_widths) + len("   ") * len(col_widths) - 3)

    for center in centers:
        row = list([center])
        for histology_type in HISTOLOGY_TYPES:
            count = len(cli_df[(cli_df['Center'] == center) &
                               (cli_df['Histology_Type'] == histology_type)])
            row.append(format(count, ',d'))

        print "##  ",
        print "   ".join(["%-*s" % (col_widths[i], row[i]) for i in xrange(num_cols)])


def print_cli_count_breakdown(cli_df, cli_colname):
    """Print a sample count in the clinical_df broken down by the values in the
    specified cli_colname (x-dimension) and by the centers (y-dimension)."""

    print "##"
    print "## Clinical '%s' Count Breakdown:" % cli_colname

    centers = sorted(set(cli_df['Center'].unique()))

    if cli_colname == 'Gender':
        enum_types = GENDER_TYPES
    elif cli_colname == 'Biopsy_Site_Type':
        enum_types = BIOPSY_SITE_TYPES
    elif cli_colname in ['ER_Status', 'PR_Status', 'HER2_Status']:
        enum_types = RECEPTOR_STATUSES
    elif cli_colname == 'Histology_Type':
        enum_types = HISTOLOGY_TYPES
    else:
        raise Exception("Invalid cli_colname (%s)" % cli_colname)

    # Consistency check
    assert set(cli_df[cli_colname].unique()) <= set(enum_types)

    header_line = "   ".join(["%-20s" % var for var in ['Center'] + enum_types])
    header_line = header_line.rstrip(" ")
    print "##"
    print "##   " + header_line
    print "##   " + "-" * len(header_line)

    for center in centers:
        row = list([center])
        for enum_type in enum_types:
            count = len(cli_df[(cli_df['Center'] == center) &
                               (cli_df[cli_colname] == enum_type)])
            row.append(format(count, ',d'))

        print "##  ",
        print "   ".join(["%-20s" % var for var in row])

def perform_missing_clinical_filtering(maf_df, cli_df):
    """Keep only samples with clinical data (i.e. filter-out all MAF_only samples).
    """

    keep_samples = set(cli_df['Tumor_Sample_Barcode'].unique())

    cli_df = cli_df[cli_df['Tumor_Sample_Barcode'].isin(keep_samples)]
    maf_df = maf_df[maf_df['Tumor_Sample_Barcode'].isin(keep_samples)]

    return maf_df, cli_df

def perform_gender_filtering(maf_df, cli_df, filter_type):
    """Keep only samples in clinical_df in which the patient's gender matches
    the specified filter.

    Notes
    -----
    - If filter_type is "EXCLUDE_MALE", then exclude all 'Male' samples. Retain
     'Famale' and 'Unknown' Gender samples.
    """
    if filter_type == "EXCLUDE_MALE":
        keep_samples = set(cli_df[cli_df['Gender'] != "Male"]['Tumor_Sample_Barcode'].unique())

        cli_df = cli_df[cli_df['Tumor_Sample_Barcode'].isin(keep_samples)]
        maf_df = maf_df[maf_df['Tumor_Sample_Barcode'].isin(keep_samples)]

    else:
        raise Exception("Invalid filter_type: %s" % filter_type)

    return maf_df, cli_df

def perform_biopsy_site_type_filtering(maf_df, cli_df, filter_type):
    """Keep only samples in clinical_df in which the sample's Biopsy_Site_Type matches
    the specified filter.

    Notes
    -----
    - If filter_type is "PRIMARY_ONLY", then keep only samples with
     "PRIMARY" biopsy_site_type.
    """

    if filter_type == "PRIMARY_ONLY":
        keep_samples = set(cli_df[cli_df['Biopsy_Site_Type'] == "Primary"]['Tumor_Sample_Barcode'].unique())

        cli_df = cli_df[cli_df['Tumor_Sample_Barcode'].isin(keep_samples)]
        maf_df = maf_df[maf_df['Tumor_Sample_Barcode'].isin(keep_samples)]

    else:
        raise Exception("Invalid filter_type: %s" % filter_type)

    return maf_df, cli_df

def import_annotated_maf(infile):
    """Import the maf2maf (VEP) annotated MAF file.

    Notes
    -----
    (1) This infile is a tab-delimited MAF file. For full-spec, see:

            https://github.com/mskcc/vcf2maf/blob/master/docs/vep_maf_readme.txt

    (2) This infile should additionally have the custom 'Source_Maf' column
        which indicate the (pre-merge) source MAF that each variant call
        originally came from.
    """

    annotated_maf_df = pd.read_table(infile, sep="\t", dtype=str, comment="#", header = 0)

    assert 'Hugo_Symbol' in annotated_maf_df

    # Rename the 'Hugo_Symbol' column to 'Gene_Symbol' to avoid confusion. Reason
    # is that the symbol values in the 'Hugo_Symbol' can originate from various
    # gene_symbol sources and does not necessary need to come from 'HGNC'.
    # For details see:
    #    http://useast.ensembl.org/info/docs/tools/vep/vep_formats.html
    #
    # The vep tool itself calls the field 'SYMBOL'. It is the vcf2maf tool
    # which maps these values to the 'Hugo_Symbol' field. See:
    #   https://github.com/mskcc/vcf2maf/blob/v1.6.9/vcf2maf.pl#L537
    annotated_maf_df = annotated_maf_df.rename(columns={'Hugo_Symbol': 'Gene_Symbol'})

    return annotated_maf_df

def add_clinical_indicator_columns(clinical_df):
    """Add the following Clinical Indicator Columns to Clinical DF:

        (1) ER+
        (2) ER-
        (3) HER2+
        (4) HER2-
        (5) TN (Triple_Negative)
        (6) Not_TN (Not Triple_Negative)
        (7) ER+/HER2+
        (8) ER-/HER2+
        (9) ER+/PR+
        (10) ER+/PR-
        (11) IDC (Invasive_Ductal_Carcinoma)
        (12) ILC (Invasive_Lobular_Carcinoma)
        (11) IDC/ER+
        (12) ILC/ER+

    Purpose of these columns is to simplify the downstream querying.
    """

    clinical_df['ER+'] = (clinical_df['ER_Status'] == 'Positive')
    clinical_df['ER-'] = (clinical_df['ER_Status'] == 'Negative')
    clinical_df['HER2+'] = (clinical_df['HER2_Status'] == 'Positive')
    clinical_df['HER2-'] = (clinical_df['HER2_Status'] == 'Negative')

    # TN (Triple-Negative): All 3 receptors are Negative.
    clinical_df['TN'] = ((clinical_df['ER_Status'] == 'Negative') &
                         (clinical_df['PR_Status'] == 'Negative') &
                         (clinical_df['HER2_Status'] == 'Negative'))

    # Not_TN: Has data for all 3 receptors and at least 1 receptor is Positive.
    clinical_df['Not_TN'] = ((clinical_df['ER_Status'] != 'Unknown') &
                             (clinical_df['PR_Status'] != 'Unknown') &
                             (clinical_df['HER2_Status'] != 'Unknown') &
                             (clinical_df['TN'] == False))

    clinical_df['ER+/HER2+'] = (clinical_df['ER_Status'] == 'Positive') & (clinical_df['HER2_Status'] == 'Positive')
    clinical_df['ER-/HER2+'] = (clinical_df['ER_Status'] == 'Negative') & (clinical_df['HER2_Status'] == 'Positive')
    clinical_df['ER+/PR+'] = (clinical_df['ER_Status'] == 'Positive') & (clinical_df['PR_Status'] == 'Positive')
    clinical_df['ER+/PR-'] = (clinical_df['ER_Status'] == 'Positive') & (clinical_df['PR_Status'] == 'Negative')

    clinical_df['IDC'] = (clinical_df['Histology_Type'] == 'Invasive_Ductal_Carcinoma')
    clinical_df['ILC'] = (clinical_df['Histology_Type'] == 'Invasive_Lobular_Carcinoma')

    clinical_df['IDC/ER+'] = (clinical_df['IDC'] & clinical_df['ER+'])
    clinical_df['ILC/ER+'] = (clinical_df['ILC'] & clinical_df['ER+'])

    # Consistency check
    assert set(CLINICAL_INDICATORS) <= set(clinical_df)

    return clinical_df

def check_clinical_df(df):
    """Perform consistency check on the clinical_df."""

    # Consistency checks
    # (1) Ensure that clinical_df have the expected columns
    assert set(df) == set(CLINICAL_COLUMNS)

    # (2) Ensure that there are no duplicated 'Tumor_Sample_Barcode values [Note: similar to (6)]
    assert not df.duplicated(subset=["Tumor_Sample_Barcode"]).any()

    # (3) Ensure that there is no missing data in any of the columns.
    assert not df.isnull().values.any()

    # (4) Ensure that Receptor_Status columns has the expected values
    for receptor in RECEPTORS:
        colname = receptor + '_Status'
        invalid_values = list(set(df[colname].unique()) - set(RECEPTOR_STATUSES))
        if len(invalid_values) != 0:
            raise Exception("Found invalid value(s) %s in '%s' column." % (invalid_values, colname))

    # (5) Ensure that the 'Biopsy_Site_Type' column has the expected values
    invalid_values = list(set(df['Biopsy_Site_Type'].unique()) - set(BIOPSY_SITE_TYPES))
    if len(invalid_values) != 0:
        raise Exception("Found invalid value(s) %s in 'Biopsy_Site_Type' column." % (invalid_values))

    # (6) Ensure that the 'Histology_Types' column has the expected values
    invalid_values = list(set(df['Histology_Type'].unique()) - set(HISTOLOGY_TYPES))
    if len(invalid_values) != 0:
        raise Exception("Found invalid value(s) %s in 'Histology_Types' column." % (invalid_values))

    # (6) Ensure that the 'Gender' column has the expected values
    invalid_values = list(set(df['Gender'].unique()) - set(GENDER_TYPES))
    if len(invalid_values) != 0:
        raise Exception("Found invalid value(s) %s in 'Gender' column." % (invalid_values))

    # (7) Ensure that 'Tumor_Sample_Barcode' serve as a unique key/index.
    assert df.index.is_unique

def import_clinical_df(infile):
    """Import the merged Clinical data file."""

    df = pd.read_table(infile, sep="\t", dtype=str, comment="#", header=0)

    # Set 'Tumor_Sample_Barcode' as the index of the Dataframe (for fast
    # lookup in downstream functions).
    df.index = df['Tumor_Sample_Barcode']

    check_clinical_df(df)

    return df

def import_target_intervals(target_bed_file):
    """Import the target_intervals from the target_bed_file."""

    bed_obj = pybedtools.BedTool(target_bed_file)
    target_intervals = bed_obj.as_intervalfile()

    return target_intervals

def map_source_maf_id_to_target_intervals(source_maf_ids, target_bed_files):
    """Create a dictionary mapping source_maf_id to target_bed_file. Assumes that
    the two lists are ordered such that their index can be used for the mapping."""

    return_dict = dict()

    # Consistency checks
    assert isinstance(source_maf_ids, list)
    assert isinstance(target_bed_files, list)
    assert len(source_maf_ids) == len(set(source_maf_ids))
    assert len(source_maf_ids) == len(target_bed_files)

    for index in range(len(source_maf_ids)):
        source_maf_id = source_maf_ids[index]
        target_intervals = import_target_intervals(target_bed_files[index])
        return_dict[source_maf_id] = target_intervals

    return return_dict

def map_source_maf_id_to_center(source_maf_ids, maf_df):
    """Create a dictionary mapping source_maf_id to center name.

    Note
    ----
    Check that if two rows in maf_df has the same 'source_maf_id' value
    then the two rows must have the same 'center' value as well.
    """

    return_dict = dict()

    # Consistency check
    assert isinstance(source_maf_ids, list)
    assert len(source_maf_ids) == len(set(source_maf_ids))

    for source_maf_id in source_maf_ids:
        temp_df = maf_df[maf_df['Source_Maf'] == source_maf_id]
        centers = list(temp_df['Center'].unique())

        if len(centers) == 0:
            raise Exception("source_maf_id '%s' maps to no center." % source_maf_id)

        if len(centers) > 1:
            raise Exception("source_maf_id '%s' maps to multiple centers: %s" % (source_maf_id, centers))

        return_dict[source_maf_id] = centers[0]

    return return_dict

def map_source_maf_id_to_num_samples(source_maf_ids, maf_df, clinical_df):
    """Create a dictionary mapping source_maf_id to # of unique samples with the
    source_maf_id in the maf_df."""

    return_dict = dict()

    # Consistency check
    assert isinstance(source_maf_ids, list)
    assert len(source_maf_ids) == len(set(source_maf_ids))

    for source_maf_id in source_maf_ids:
        samples_in_maf = get_unique_samples(source_maf_id, maf_df)
        return_dict[source_maf_id] = dict()
        return_dict[source_maf_id]['Total'] = len(samples_in_maf)

        if isinstance(clinical_df, pd.DataFrame):
            for indicator in CLINICAL_INDICATORS:
                return_dict[source_maf_id][indicator] = get_num_samples_with_indicator(indicator,
                                                                                       samples_in_maf,
                                                                                       clinical_df)

    # Print a WARNING message if there are orphan 'Source_Maf' values in
    # maf_df that is not in source_maf_ids.
    orphan_maf_ids = list(set(maf_df['Source_Maf'].unique()) - set(source_maf_ids))
    if len(orphan_maf_ids) != 0:
        print "##"
        print "## WARNING: Found orphan 'Source_Maf' value(s) %s which do not appear" % orphan_maf_ids,
        print "in provided source_maf_ids list."
        print "## WARNING: Samples in MAF file with these 'Source_Maf' value(s)",
        print "will be excluded from the targeted/untargeted sample counts."

    return return_dict

def map_transcript_id2gene_symbol(maf_df):
    """Create and return a mapping from transcript_id to gene_symbol. Assume that each
    transcript_id uniquely maps to a gene_symbol."""

    transcript_id2gene_symbol = dict()

    for index, row in maf_df.iterrows():

        gene_symbol = row['Gene_Symbol']  # e.g. 'AFF2'
        transcript_id = row['Transcript_ID']  # e.g. 'ENST00000369354' (Ensembl transcript ID)

        if transcript_id not in transcript_id2gene_symbol:
            transcript_id2gene_symbol[transcript_id] = gene_symbol
        else:
            assert transcript_id2gene_symbol[transcript_id] == gene_symbol

    return transcript_id2gene_symbol

def get_unique_samples(source_maf_id, maf_df):
    """Get a set of unique samples in maf_df with the specified source_maf_id."""

    temp_df = maf_df[maf_df['Source_Maf'] == source_maf_id]

    samples = set(temp_df['Tumor_Sample_Barcode'].unique())

    if len(samples) == 0:
        print "##"
        print "## WARNING: Found 0 sample in MAF file with source_maf_id %s." % repr(source_maf_id)

    return samples

def get_num_samples_with_indicator(indicator, query_samples, clinical_df):
    """Return number of samples among query_samples that has the desired clinical
    indicator (e.g. ER+) in clinical_df."""

    num_samples = 0

    assert indicator in CLINICAL_INDICATORS

    for sample in query_samples:
        if sample in clinical_df.index:
            if clinical_df.loc[sample][indicator]:
                num_samples += 1

    return num_samples

def check_center(centers):
    """Check if any of the center have a '|' characeter in their name

    Reasoning is that we will use '|' character as delimit the centers
    in the mutation count outfile.
    """

    for center in centers:
        if "|" in center:
            # Not allowed since with use '|' character to delimit the centers in
            #  mutation count outfile.
            raise Exception("Found '|' character in center name %s." % repr(center))

def check_gene2transcript_mapping(codon_level_dict):
    """Iterate through the gene_ids and print a warning message for each gene_id
    that maps to multiple transcript_ids.

    Note (Jan 12th, 2017)
    ---------------------
    When ran on DFCI + METABRIC + TCGA + SANGER Breast Cancer datasets, didn't
    find any case with at least 3 counts, where gene_id maps to multiple
    transcript_ids [Jan 12th, 2017].
    """

    gene2transcripts = dict()

    for codon_id in sorted(codon_level_dict):

        gene_id = codon_id.gene_id
        transcript_id = codon_id.transcript_id

        if gene_id not in gene2transcripts:
            gene2transcripts[gene_id] = set()

        gene2transcripts[gene_id].add(transcript_id)

    for gene_id in sorted(gene2transcripts.iterkeys()):

        transcript_ids = sorted(list(gene2transcripts[gene_id]))

        if len(transcript_ids) > 1:
            print "##"
            print "## WARNING: Gene_ID-->%s maps to multiple Transcript_IDs-->%s." % (gene_id, transcript_ids)

def check_annotated_maf(maf_df):
    """Perform various checks on the content of the annotated MAF.

    Note
    ----
    (1) Input 'maf_df should be filtered to contain only Missense SNP.
    """

    # Since SNV, both REF and ALT values should be single DNA alphabet.
    assert set(maf_df['Reference_Allele'].unique()) <= set(["A", "C", "G", "T"])
    assert set(maf_df['Tumor_Seq_Allele1'].unique()) <= set(["A", "C", "G", "T"])

    # Ensure no missing data in specific columns.
    assert not maf_df['Gene_Symbol'].isnull().values.any()
    assert not maf_df['Gene'].isnull().values.any()
    assert not maf_df['Transcript_ID'].isnull().values.any()
    assert not maf_df['Protein_position'].isnull().values.any()
    assert not maf_df['Amino_acids'].isnull().values.any()
    assert not maf_df['Source_Maf'].isnull().values.any()

    # Each 'Gene' (Ensembl gene ID) value map to an unique 'Gene_Symbol' value
    # by VEP.
    assert maf_df.groupby('Gene')['Gene_Symbol'].nunique().min() == 1
    assert maf_df.groupby('Gene')['Gene_Symbol'].nunique().max() == 1

    # However, note that there are rare cases where the converse is not true.
    # A 'Gene_Symbol' value does not necessary map to map to a unique 'Gene'
    # (Ensembl gene ID) value. This is since VEP annotates 'Gene_Symbol' values
    # using multiple symbol sources (e.g. HGNC, UniProtKB Gene Name).
    # For example:
    #   (1) HGNC's CRYBG3 maps to 'ENSG00000080200' and
    #   (2) UniProtKB's CRYBG3 maps to 'ENSG00000233280'
    assert maf_df.groupby('Gene_Symbol')['Gene'].nunique().min() == 1
    if maf_df.groupby('Gene_Symbol')['Gene'].nunique().max() != 1:
        index = 0
        for gene_symbol, group in maf_df.groupby('Gene_Symbol'):
            gene_ids = sorted(list(group['Gene'].unique()))
            if len(gene_ids) > 1:
                print "##"
                print "## WARNING: Gene_Symbol-->%s maps to multiple Ensemble Gene_IDs-->%s." % (repr(gene_symbol), gene_ids)

def apply_missense_snp_filter(maf_df):
    """Filter for SNP variants that have a 'missense' effect.

    Notes
    -----
    (1) Previously applied the following filter:

            maf_df = maf_df[maf_df['Variant_Classification'] == 'Missense_Mutation']

        However found that the above filter was too permissive and include (rare)
        variants where 'Consequence' value is 'coding_sequence_variant' (which is
        not a 'missense_variant').

        The reason is because the 'Missense_Mutation' value is computed by vcf2maf
        tool and maps one of the following 'Consequence' values:
            (1) missense_variant
            (2) coding_sequence_variant
            (3) conservative_missense_variant
            (4) rare_amino_acid_variant

         Also See:
            http://useast.ensembl.org/info/genome/variation/predicted_data.html
            http://www.sequenceontology.org/miso/current_release/term/SO:0001580
    """

    maf_df = maf_df[maf_df['Consequence'].str.contains('missense_variant')]
    maf_df = maf_df[maf_df['Variant_Type'] == 'SNP']

    return maf_df

def apply_exac_filter(maf_df):
    """Filter-out variant calls with Adjusted ExAC Allele Frequency above 0.06% (to remove
    putative germline variants)."""

    total_variant_calls = len(maf_df)

    # Print excluded variants for debugging/logging purpose.
    exclude_indices = maf_df[maf_df['ExAC_AF_Adj'].astype(float).fillna(0.0) > 0.0006].index.tolist()

    print "##"
    print "## Performing ExAC Allele Frequency Filter..."
    print "##"
    print "## Filtered-out %s variant calls with ExAC_AF_Adj > 0.06%%" % format(len(exclude_indices), ',d'),
    print "(Note: out of %s total variant calls)" % format(total_variant_calls, ',d')

    # Drop the variants
    maf_df.drop(exclude_indices, inplace=True)

    # Consistency check
    assert len(maf_df) == total_variant_calls - len(exclude_indices)

    return maf_df


def run_hotspot_stats_model(in_maf_df,
                            source_maf_id2target_intervals,
                            source_maf_id2num_samples,
                            source_maf_id2center,
                            min_count,
                            gene_annotation_gtf_file,
                            ref_fasta_file,
                            ref_fasta_fai_file,
                            use_toy_stats_model):
    """Run the Logistic Regression Model (with Fixed Effects) to determine
    statistical significance (p-value and q-value) of each putative hotspot.

    Return a list of 'hotspot_stats' objection which contains the statistical
    information (e.g. p-value, q-value) of each hotspot.
    """

    print "##"
    print "## Run Logistic Regression Model (with Fixed Effects) to determine",
    print "statistical significance of each putative hotspot."

    local_maf_df = copy.deepcopy(in_maf_df)  # Create a local copy of maf_df.

    prefiltered_genes = hotspot_stats_model.get_prefiltered_genes(local_maf_df)

    local_maf_df = local_maf_df[local_maf_df['Gene_Symbol'].isin(prefiltered_genes)]

    ref_trinucleotide_map = create_ref_trinuc_map.run_wrapper(local_maf_df,
                                                              gene_annotation_gtf_file,
                                                              ref_fasta_file,
                                                              ref_fasta_fai_file,
                                                              VERSION)

    stats_data_list = hotspot_stats_model.run_wrapper(local_maf_df,
                                                      ref_trinucleotide_map,
                                                      source_maf_id2target_intervals,
                                                      source_maf_id2num_samples,
                                                      source_maf_id2center,
                                                      min_count,
                                                      VERSION,
                                                      use_toy_stats_model)

    return stats_data_list


def add_stats_data_to_codon_level_dict(stats_data_list, codon_level_dict, maf_transcript_id2gene_symbol):
    """
    Add the statistical data (e.g. p-value, q-value) from the logistic
    regression fitting to the codon_level_dict_object.

    Notes
    -----
    (1) Print WARNING messages to indicate codons that are found only in either
        hotspot_stats_data_list or codon_level_dict (BUT not both).

    (2) maf_transcript_id2gene_symbol is derived from the MAF_file and is used here
        for consistency check.
    """

    # Each combination of transcript_id and codon_pos should uniquely determine
    # CodonID since each transcript_id maps to an unique gene_id.
    KeyID = namedtuple("KeyID", ["transcript_id", "codon_pos"])
    key_id2codon_id = dict()

    for codon_id in codon_level_dict:
        transcript_id = codon_id.transcript_id
        codon_pos = codon_id.codon_pos
        key_id = KeyID(transcript_id=transcript_id, codon_pos=codon_pos)

        assert key_id not in key_id2codon_id
        key_id2codon_id[key_id] = codon_id

    for stats_data in stats_data_list:
        gene_symbol = stats_data["Gene_Symbol"]
        transcript_id = stats_data["Transcript_ID"]
        codon_pos = stats_data["Codon_Pos"]
        key_id = KeyID(transcript_id=transcript_id, codon_pos=codon_pos)

        # Perform various checks and print WARNING messages for debugging/logging purposes.
        if transcript_id in maf_transcript_id2gene_symbol:
            maf_gene_symbol = maf_transcript_id2gene_symbol[transcript_id]
            if maf_gene_symbol != gene_symbol:
                print "##"
                print "## WARNING: Gene_Symbol derived from 'MAF' and from 'stats_data' does not match!"
                print "## WARNING: Problem MAF's Gene_Symbol:", repr(maf_gene_symbol)
                print "## WARNING: Problem Stats_Data's Gene_Symbol:", repr(gene_symbol)
        else:
            print "##"
            print "## WARNING: transcript_id (%s) is not in maf_transcript_id2gene_symbol" % transcript_id

        if key_id in key_id2codon_id:
            codon_id = key_id2codon_id[key_id]
            assert 'stats_data' not in codon_level_dict[codon_id]
            codon_level_dict[codon_id]['stats_data'] = stats_data

            mutation_count1 = codon_level_dict[codon_id]['Num_Samples_with_Mutation']['Total']
            mutation_count2 = stats_data['Num_Samples_with_Mutation']

            if mutation_count1 != mutation_count2:
                print "##"
                print "## WARNING: [Gene_Symbol: %s] Inconsistent mutation_count for codon_id (%s)." % (gene_symbol, str(codon_id ))
                print "## WARNING: codon_level_dict's mutation_count:", repr(mutation_count1)
                print "## WARNING: stats_data' mutation_count:", repr(mutation_count2)

        else:
            print "##"
            print "## WARNING: [Gene_Symbol: %s] stats_data's key_id (%s) " % (gene_symbol, str(key_id)),
            print "does not match any codon_level_dict's codon_id."
            continue

    # Print WARNING messages for debugging/logging purposes.
    sorted_codon_ids = [kk for kk, vv in
                        sorted(codon_level_dict.iteritems(),
                               key=lambda(k, v): (v['Gene_Symbol'], k.gene_id, k.transcript_id, k.codon_pos))]

    for codon_id in sorted_codon_ids:
        if 'stats_data' not in codon_level_dict[codon_id]:
            gene_symbol = codon_level_dict[codon_id]['Gene_Symbol']
            print "##"
            print "## WARNING: [Gene_Symbol: %s] codon_level_dict's codon_id (%s)" % (gene_symbol, str(codon_id)),
            print "does not have any corresponding stats_data."


def aggregate_codon_level_data(maf_df, clinical_df):
    """
    Aggregate Data in MAF at the per-Gene, per-Codon level dictionary
    object.
    """

    codon_level_dict = dict()

    all_centers = list(maf_df['Center'].unique())
    all_source_maf_ids = list(maf_df['Source_Maf'].unique())

    for idx, row in maf_df.iterrows():

        gene_symbol = row['Gene_Symbol']  # e.g. 'AFF2'
        gene_id = row['Gene']  # e.g. 'ENSG00000080200' (Ensembl gene ID)
        transcript_id = row['Transcript_ID']  # e.g. 'ENST00000369354' (Ensembl transcript ID)
        center = row['Center']  # e.g. 'METABRIC'
        source_maf_id = row['Source_Maf']

        # row['Protein_position'] --> e.g. '374/1130'
        assert len(row['Protein_position'].split("/")) == 2

        codon_pos = int(row['Protein_position'].split("/")[0])  # e.g. 374

        # row['Amino_acids'] --> e.g. 'S/L'
        assert len(row['Amino_acids'].split("/")) == 2
        ref_aa = row['Amino_acids'].split("/")[0]
        alt_aa = row['Amino_acids'].split("/")[1]
        assert len(ref_aa) == 1
        assert len(alt_aa) == 1

        # Assume filtered to include only SNP at this point.
        assert int(row['Start_Position']) == int(row['End_Position'])
        position = int(row['Start_Position'])

        codon_id = CodonID(gene_id=gene_id, transcript_id=transcript_id, codon_pos=codon_pos)

        if codon_id not in codon_level_dict:
            codon_level_dict[codon_id] = dict()

            for key in ['Gene_Symbol', 'Ref_AA', 'Alt_AA', 'Chromosome', 'Position', 'Transcript_ID', 'ExAC_AF_Adj']:
                codon_level_dict[codon_id][key] = set()

            codon_level_dict[codon_id]['Num_Samples_with_Mutation'] = dict()
            codon_level_dict[codon_id]['Num_Samples_with_Mutation']['Total'] = 0

            codon_level_dict[codon_id]['Num_Samples_with_Mutation']['PerCenter'] = {key: 0 for key in all_centers}
            codon_level_dict[codon_id]['Num_Samples_with_Mutation']['PerSourceMafID'] = {key: 0 for key in all_source_maf_ids}

            codon_level_dict[codon_id]['Num_Samples_with_Mutation']['Clinical_Indicator'] = dict()
            for key1 in CLINICAL_INDICATORS:
                codon_level_dict[codon_id]['Num_Samples_with_Mutation']['Clinical_Indicator'][key1] = dict()
                codon_level_dict[codon_id]['Num_Samples_with_Mutation']['Clinical_Indicator'][key1]['AllCenters'] = 0
                codon_level_dict[codon_id]['Num_Samples_with_Mutation']['Clinical_Indicator'][key1]['PerCenter'] = dict()
                for key2 in all_centers:
                    codon_level_dict[codon_id]['Num_Samples_with_Mutation']['Clinical_Indicator'][key1]['PerCenter'][key2] = 0

        codon_level_dict[codon_id]['Gene_Symbol'].add(gene_symbol)
        codon_level_dict[codon_id]['Ref_AA'].add(ref_aa)
        codon_level_dict[codon_id]['Alt_AA'].add(alt_aa)
        codon_level_dict[codon_id]['Chromosome'].add(row['Chromosome'])
        codon_level_dict[codon_id]['Position'].add(position)
        codon_level_dict[codon_id]['ExAC_AF_Adj'].add(float(row['ExAC_AF_Adj']))

        codon_level_dict[codon_id]['Num_Samples_with_Mutation']['Total'] += 1
        codon_level_dict[codon_id]['Num_Samples_with_Mutation']['PerCenter'][center] += 1
        codon_level_dict[codon_id]['Num_Samples_with_Mutation']['PerSourceMafID'][source_maf_id] += 1

        # Add Clinical Counts for each clinical indicator.
        if isinstance(clinical_df, pd.DataFrame):
            sample = row['Tumor_Sample_Barcode']
            if sample in clinical_df.index:
                for indicator in CLINICAL_INDICATORS:
                    if clinical_df.loc[sample][indicator]:
                        codon_level_dict[codon_id]['Num_Samples_with_Mutation']['Clinical_Indicator'][indicator]['AllCenters'] += 1
                        codon_level_dict[codon_id]['Num_Samples_with_Mutation']['Clinical_Indicator'][indicator]['PerCenter'][center] += 1

    # 'Gene_Symbol', 'Ref_AA', and 'Chromosome' fields should each have an unique
    # value for each (Gene_ID, Transcript_ID, Codon) Combination. So convert the
    # set object to its singleton element.
    exceptions = list()

    for key in ['Gene_Symbol', 'Ref_AA', 'Chromosome']:
        for codon_id in sorted(codon_level_dict):

            value = codon_level_dict[codon_id][key]
            assert isinstance(value, set)  # consistency check
            value = sorted(list(value))

            if len(value) == 1:
                # extract the singleton element in the set.
                codon_level_dict[codon_id][key] = value[0]
            elif len(value) == 0:
                msg = "Codon '%s' of Gene_ID|Transcript_ID '%s|%s' maps to no '%s' value." % (codon_id.codon_pos,
                                                                                              codon_id.gene_id,
                                                                                              codon_id.transcript_id,
                                                                                              key)
                exceptions.append(msg)
            else:
                msg = "Codon '%s' of Gene_ID|Transcript_ID '%s|%s' maps to multiple '%s' values: %s." % (codon_id.codon_pos,
                                                                                                         codon_id.gene_id,
                                                                                                         codon_id.transcript_id,
                                                                                                         key,
                                                                                                         value)
                exceptions.append(msg)

    if len(exceptions) != 0:
        all_msg = "Found issue(s) with content of codon_level_dict:\n"
        for idx, msg in enumerate(exceptions, start=1):
            all_msg += "    [%04d] %s\n" % (idx, msg)
        raise Exception(all_msg)

    return codon_level_dict


def apply_min_count_filter(codon_level_dict, min_count):
    """Remove codons with mutation count below specified threshold."""

    filtered_codon_level_dict = copy.deepcopy(codon_level_dict)

    for codon_id in codon_level_dict:
        if codon_level_dict[codon_id]['Num_Samples_with_Mutation']['Total'] < min_count:
            del filtered_codon_level_dict[codon_id]

    return filtered_codon_level_dict


def apply_is_hotspot_qvalue_filter(codon_level_dict, max_qvalue_cutoff):
    """
    Remove codons with 'is_hotspot' qvalue above specified threshold.

    Notes
    -----
    (1) Also remove codons with missing stats_data's qvalue.
    """

    filtered_codon_level_dict = copy.deepcopy(codon_level_dict)

    for codon_id in codon_level_dict:
        pass_filter = False

        if 'stats_data' in codon_level_dict[codon_id]:
            stats_data = codon_level_dict[codon_id]['stats_data']
            if stats_data['QValue'] <= max_qvalue_cutoff:
                pass_filter = True

        if not pass_filter:
            del filtered_codon_level_dict[codon_id]

    return filtered_codon_level_dict


def write_output_table(out_data_table, outfile):
    """Write the data in the out_data_table to the specified outfile."""

    fout = open(outfile, 'w')

    # Write the script version
    fout.write("##Version=%s\n" % VERSION)

    for row in out_data_table:

        fout.write("\t".join(row) + '\n')

    fout.close()


if __name__ == '__main__':

    print "## Enter %s (%s).\n##" % (os.path.basename(__file__), time.asctime())

    start_time = time.time()

    parser = argparse.ArgumentParser()

    parser.add_argument("--in_maf", action="store", required=True,
                        metavar='FILE',
                        help="Path to input MAF file.")

    parser.add_argument("--in_clinical", action="store",
                        metavar='FILE',
                        help="Path to input Clinical Data file.")

    parser.add_argument("--in_source_maf_ids", action="store", required=True,
                        nargs='+',
                        help="Source_Maf IDs for mapping with target bed files (by ordering).")

    parser.add_argument("--in_target_beds", action="store", required=True,
                        nargs='+',
                        help="Target bed files for mapping with Source_Maf IDs (by ordering).")

    parser.add_argument("--min_count", action="store", type=int, default=5,
                        help="Don't report codon with mutation counts below this threshold.")

    parser.add_argument("--run_hotspot_stats_model", action="store_true", default=False,
                        help="Detect hotspots using a stats model instead of just count-base model.")

    parser.add_argument("--use_toy_stats_model", action="store_true", default=False,
                        help="Use a simplified stats model for hotspot detection (note: only for testing).")

    parser.add_argument("--gene_annotation_gtf", action="store", metavar='FILE', default=None,
                        help="Gene Annotation GTF resource file (only used by hotspot_stats_mode).")

    parser.add_argument("--ref_fasta", action="store", metavar='FILE', default=None,
                        help="Reference Genome Fasta file (only used by hotspot_stats_mode).")

    parser.add_argument("--ref_fasta_fai", action="store", metavar='FILE', default=None,
                        help="Reference Genome Fasta Index file (only used by hotspot_stats_mode).")

    parser.add_argument("--hotspot_qvalue_cutoff", action="store", type=float, default=0.1,
                        help="Don't report codon with 'is_hotspot' q-value above this threshold.")

    parser.add_argument("--biopsy_site_type_filter", action="store", default="PRIMARY_ONLY",
                        choices = ["PRIMARY_ONLY", "NONE"],
                        help="""If 'PRIMARY_ONLY', then filter for only 'Primary'. samples.
                             If 'NONE', then don't perform filter.""")

    parser.add_argument("--output_clinical_counts", action="store_true", default=False,
                        help="Output the counts of each clinical indicator.")

    parser.add_argument("--percenter_breakdown", action="store_true", default=False,
                        help="Output breakdown of sample counts at each Center.")

    parser.add_argument("--out_table", action="store", default=None,
                        metavar='FILE',
                        help="""Path to the output table. If omitted, then don't output the
                             table (this feature is necessary as a Reliance Point workaround).""")

    options = parser.parse_args()

    for index in range(len(options.in_target_beds)):
        options.in_target_beds[index] = os.path.abspath(options.in_target_beds[index])

    print "##", "-" * 50
    print "## Program Version:", repr(VERSION)
    print "## Specified Options:"
    print "##   in_maf:", repr(options.in_maf)
    print "##   in_clinical:", repr(options.in_clinical)
    print "##   in_source_maf_ids:"
    for index, source_maf_id in enumerate(options.in_source_maf_ids, start=1):
        print "##       (%d) %s" % (index, repr(source_maf_id))
    print "##   in_target_beds:"
    for index, target_bed in enumerate(options.in_target_beds, start=1):
        print "##       (%d) %s" % (index, repr(target_bed))
    print "##   min_count:", repr(options.min_count)
    print "##   run_hotspot_stats_model:", repr(options.run_hotspot_stats_model)
    print "##   use_toy_stats_model:", repr(options.use_toy_stats_model)
    print "##   gene_annotation_gtf:", repr(options.gene_annotation_gtf)
    print "##   ref_fasta:", repr(options.ref_fasta)
    print "##   ref_fasta_fai:", repr(options.ref_fasta_fai)
    print "##   hotspot_qvalue_cutoff:", repr(options.hotspot_qvalue_cutoff)
    print "##   biopsy_site_type_filter:", repr(options.biopsy_site_type_filter)
    print "##   output_clinical_counts:", repr(options.output_clinical_counts)
    print "##   percenter_breakdown:", repr(options.percenter_breakdown)
    print "##   out_table:", repr(options.out_table)
    print "##", "-" * 50

    for source_maf_id in options.in_source_maf_ids:
        if options.in_source_maf_ids.count(source_maf_id) > 1:
            raise Exception("User specified source_maf_id '%s' more than once!" % source_maf_id)

    for target_bed_file in options.in_target_beds:
        if not os.path.isfile(target_bed_file):
            raise Exception("User specified target_bed_file '%s' is a not a valid existing file!" % target_bed_file)

    if len(options.in_source_maf_ids) != len(options.in_target_beds):
        raise Exception("User needs to specify matching number of in_source_maf_ids and in_target_beds!")

    if options.run_hotspot_stats_model:
        if options.gene_annotation_gtf is None:
            raise Exception("Option --gene_annotation_gtf is required in 'run_hotspot_stats_model' mode.")

        if options.ref_fasta is None:
            raise Exception("Option --ref_fasta is required in 'run_hotspot_stats_model' mode.")

        if options.ref_fasta_fai is None:
            raise Exception("Option --ref_fasta_fai is required in 'run_hotspot_stats_model' mode.")

        if options.ref_fasta + '.fai' != options.ref_fasta_fai:
            raise Exception("Unexpected ref_fasta_fai location! Please put the"
                            " file in same directory as the ref_fasta_file.")

    main(options)

    print "##"
    print "## Exit %s" % os.path.basename(__file__),
    print '(%s | total_time = %.3f secs).' % (time.asctime(), time.time() - start_time)

    sys.exit(0)
